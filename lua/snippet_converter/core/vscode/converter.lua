local M = {}

local NodeType = require("snippet_converter.core.node_type")
local base_converter = require("snippet_converter.core.converter")
local err = require("snippet_converter.utils.error")
local io = require("snippet_converter.utils.io")
local export_utils = require("snippet_converter.utils.export_utils")

M.node_visitor = {
  [NodeType.TABSTOP] = function(node)
    if not node.transform then
      return "$" .. node.int
    end
    return ("${%s/%s}"):format(node.int, M.node_visitor[NodeType.TRANSFORM](node.transform))
  end,
  [NodeType.TRANSFORM] = function(node)
    -- Can currently only convert VSCode to VSCode regex
    if node.regex_kind ~= NodeType.RegexKind.JAVASCRIPT then
      print(node.regex_kind)
      err.raise_converter_error(
        NodeType.RegexKind.to_string(node.regex_kind) .. " regex in transform node"
      )
    end
    -- ASCII conversion option
    if node.options:match("a") then
      err.raise_converter_error("option 'a' (ascii conversion) in transform node")
    end
    -- Only g, i and m options are valid - ignore the rest
    local converted_options = node.options:gsub("[^gim]", "")

    local replacements = {}
    for i, replacement in pairs(replacements) do
      -- Text or format nodes
      replacements[i] = M.node_visitor[replacement.type](replacement)
    end
    return ("%s/%s/%s"):format(node.regex, table.concat(replacements), converted_options)
  end,
  [NodeType.FORMAT] = function(node)
    if not node.format_modifier then
      return "$" .. node.int
    end
    -- TODO: handle if / else
    return ("${%s:/}"):format(node.format_modifier)
  end,
  [NodeType.VISUAL_PLACEHOLDER] = function(_)
    err.raise_converter_error(NodeType.to_string(NodeType.VISUAL_PLACEHOLDER))
  end,
}

M.visit_node = setmetatable(M.node_visitor, {
  __index = base_converter.visit_node(M.node_visitor),
})

local escape_chars = function(str)
  -- Escape backslashes (I couldn't get this to work with gsub / regexes)
  local chars = {}
  for i = 1, #str do
    local cur_char = str:sub(i, i)
    if cur_char == "\\" then
      chars[#chars + 1] = "\\"
    end
    chars[#chars + 1] = cur_char
  end

  local item = table.concat(chars)
  -- Surround with quotes and escape whitespace + quote characters
  return ('"%s"'):format(item:gsub('[\t\r\a\b"]', {
    ["\t"] = "\\t",
    ["\r"] = "\\r",
    ["\a"] = "\\a",
    ["\b"] = "\\b",
    ['"'] = '\\"',
  }))
end

---@param lines table the input array to escape
---@param escape boolean whether the items in the list should be escaped
---@return string the JSON string representation of the list
local list_to_json_list = function(lines, escape)
  local list_items = escape and vim.tbl_map(escape_chars, lines) or lines

  -- Single list item => output a string
  if not list_items[2] then
    return ("%s"):format(list_items[1])
  end
  -- Nicely format the array
  return ("[\n      %s\n    ]"):format(table.concat(list_items, ",\n      "))
end

local string_to_json_list = function(input)
  return list_to_json_list(vim.split(input, "\n", true), true)
end

---Creates package.json file contents as expected by VSCode and Luasnip.
---@name string the name that will be added at the top of the output
---@filetypes array an array of filetypes that determine the path attribute
---@param langs_for_filetype table<string, table> maps a relative path to a snippet to an array of supported languages for that file.
---@return string the generated string to be written
local get_package_json_string = function(name, filetypes, langs_for_filetype)
  local snippets = {}
  local i = 1
  for _, filetype in ipairs(filetypes) do
    local path = ("./%s.json"):format(filetype)
    print(filetype, vim.inspect(langs_for_filetype))
    local langs = list_to_json_list(langs_for_filetype[filetype], false)
    snippets[i] = ([["language": %s,
      "path": "%s"]]):format(langs, path)
    i = i + 1
  end
  return ([[
{
  "name": "%s",
  "description": "Generated by snippet-converter.nvim [https://github.com/smjonas/snippet-converter.nvim]",
  "contributes": {
    "snippets": [
      %s
    ]
  }
}
  ]]):format(name, table.concat(snippets))
end

-- TODO: remove
M.convert = function(snippet, _, visit_node)
  if snippet.options and snippet.options:match("r") then
    err.raise_converter_error("regex trigger")
  end
  local body = string_to_json_list(
    base_converter.convert_ast(snippet.body, visit_node or M.visit_node)
  )
  if snippet.trigger == "set" then
    print(vim.inspect(snippet.body))
  end

  local description_string
  if snippet.description then
    description_string = ('\n    "description": %s,'):format(escape_chars(snippet.description))
  end
  local scope = snippet.scope
      and ('\n    "scope": %s,'):format(
        escape_chars(table.concat(snippet.scope, ","))
      )
    or ""
  local trigger = escape_chars(snippet.trigger)
  local name = (snippet.name and escape_chars(snippet.name)) or trigger
  return ([[
  %s: {
    "prefix": %s,%s%s
    "body": %s
  }]]):format(name, trigger, description_string or "", scope, body)
end

-- Takes a list of converted snippets for a particular filetype and exports them to a JSON file.
-- @param converted_snippets string[] @A list of strings where each item is a snippet string to be exported
-- @param filetype string @The filetype of the snippets
-- @param output_dir string @The absolute path to the directory to write the snippets to
M.export = function(converted_snippets, filetype, output_path)
  local snippet_lines = export_utils.snippet_strings_to_lines(converted_snippets, ",", { "{" }, "}")
  output_path = export_utils.get_output_file_path(output_path, filetype, "json")
  io.write_file(snippet_lines, output_path)
end

M.post_export = function(template, filetypes, output_path)
  local json_string = get_package_json_string(template.name, filetypes, { lua = { "lua" } })
  local lines = export_utils.snippet_strings_to_lines { json_string }
  print(vim.inspect(lines))
  -- TODO: check that output_path is a folder
  io.write_file(lines, output_path .. "/package.json")
end

return M
